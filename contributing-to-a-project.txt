contributor count: number of developers contributing code to project

How To Keep Code Up-To-Date and Commits Valid? 

Project Workflow: 

- Maintainer or integration manager checking patches

- are patches peer-reviewed and approved

Commit Access: 

- Do you have Project Write Access

--------------------------------------

Make A Good Guideline For Creating Commits & Stick To It.

Good Tips For Creating Commits From Which To Submit Patches: 

- Read In Documentation/SubmittingPatches file: file:///C:/Program%20Files/Git/mingw64/share/doc/git-doc/submittingPatches.html

I looked for the SubmittingPatches File in the online docs and couldn't find it, so I figured that they mean it is on my computer git docs, so I type "git help add" and when that opened up the computer's doc help page for it, I replaced "git-add" near the end of the url with "submittingPatches" and it opened the correct page. 

1. Submissions should not contain any whitespace errors

- check for them before committing by running the command: 

git diff --check

- whitespace errors, are whitespaces in the document that aren't needed, such as one more whitespaces at the end of line of code.

Here's a whitespace error          

which will show up when you run git diff --check.

TYGGFE!

2. Try To Make Each Commit A Logically Separate Changeset.

- Make Changes Easily Digestible

- Don't Code For Several Issues And Submit Them As One Massive Commit

- Use The Staging Area To Split Your Work Into At Least One Commit Per Issue With A Useful Message Per Commit: 

If some of the changes modify the same file, try to use: 

git add --patch

to partially stage files. 

Project Snapshot At The Tip Of The Branch Is Identical Whether You One or Many Commits, as long as all changes are added at some point.

- Try to make things easy to comprehend, understand for fellow contributors, developers.

- Doing the above makes it easier to "revert one of the changesets"

- Craft, Develop A Clean & Understandable History Before Sending The Work To Someone Else

3. Create Quality Commit Messages

- Start With A Single Line

- No Longer Than About 50 Charcters

- Describes Changeset Concisely

- Followed By A Blank Line

- Followed By A More Detailed explanation. 

-- The More Detailed Explanation Should Include: 

--- Motivation For the Change & Contrast Its Implementation With Previous Behavior

- Write In The Imperative: 

-- Correct: "Fix bug"

-- Incorrect: "Fixed bug" or "Fixes bug"

- Commit Template: 

-- Capitalized, Short (50 chars or less) Summary

-- More detailed explanatory text, if necessary. Wrap it to about 72 charcters or so. In some contexts, the first line si treated as the subject of an email and the rest of the text as the body. The blank line separating the summary from teh body is critical (unless you omit the body entirely); tools like rebase will confuse you if you run the two together. 

-- Write your commit message int eh imperative: "Fix bug"  and not "Fixed but" or "fixes bug." This convention matches up with commit messages generated by commands like "git merger" and "git revert."

-- Further paragraphs come after blank lines. 

-- Bullets points are okay, too. 

-- Typically a hyphen ( - ) or asterisk ( * ) is used for the bullet point, followed by a single space, with blank lines in between, but conventions vary here. 

-- Use a hanging indent

Private Small Team: 

- One or two other developers share a repository

- "private" here means closed-source, not accessible to the world. 

- you, three, developers have push access to repository, repo for short. 

- can follow a workflow similar to Subversion, centralized system (server-side merge), while git:

-- Merge happens client-side at commit time.

- Example: Two Developers Working together

-- John clones repo, makes change and commits change

-- Jessica clones repo, makes change, commits change, pushes work to server, repository and it works fine. 

--- git push <remote-address> <branch to push>

--- git push origin master

--- the last line in the git response, feedback has 

---- <oldref>..<newref> fromref -> toref

---- old reference.. new reference  from local reference being pushed -> name of the remote reference being updated (more info git help push to bring up the local git documentation)

---- 1edee6b..fbff5bc master -> master

-- John makes some changes, commits, and pushes them to the same server

--- John's push attempt: fails, is rejected

--- ! [rejected]     master -> master (non-fast forward) error: failed to push some refs to 'john@githost:simplegit.git'

--- His push fails because Jessica already pushed. 

-- John And Jessica Edited Their Local files. 

-- With Git, you must 1st merge the commits locally..... John must "fetch Jessica's upstream changes and merge them into his local repository" Before he can push.

-- John's 1st step: 

--- fetch the upstream work that has been pushed by someone else

---- git fetch origin

---- response: +049d078...fbff5bc master -> origin/master (Jessica's work)

----- the origin/master becomes a branch of John's local master

-- John's 2nd step: merge the origin/master branch, Jessica's work, into his own local work, master. He Must Make Sure He is On His Local master Branch before he merge (git switch master)

--- git merge origin/master

--- git notification: 

---- Merge made by the 'recursive' strategy. TODO | 1 + 1 files changed, 1 insertion(+), 0 deletions(-)

-- Now John's last commit is pointing to Jessica's last commit, push and also to his previous-last-commit.

-- But John should test his code to make sure none of Jessica's work affects any of his. If everythin seems to work fine, then he can push his code. 

--- git push origin master

---- git notification

-- Now the origin/master repository's last commit is the same as John's master's last commit, the heads are pointing to the same commit for right now. 

-- Now Jessica has to pull, fetch John's work from the repo and merge it to be able to push here new work. 

-- She has to find out what part of John's work has to be merged in with her local master so that she can push her changes, topic-branch. 

--- she runs git log to find out: 

---- git log --no-merges <topic-branch-or-branch>..<target-branch>

----- this log filter tells you what is on the target-branch that the topic-branch-or-branch, 1st doesn't have

---- git log --no-merges issue54..origin/master

-- Now Jessica merges her topic-branch-work into her master branch and then merges John's work into her branch, and pushes it all to the server, repository. 

-- Then she switches to local-master and does a fast-forward commit

**** Something similar happened to me. I made a commit and pushed to the repo. Then I wanted to amend the last commit I did to correct something, but when I tried to push to the repository I got that error, but I did a "get pull" (fetch and automatic merge) instead and then push.

Private Managed Team:

- large private group

- small groups collaborate on features

- small groups, team based contributions are integrated by another part. 

- To Push To A Branch That Is Name Differently Than Your Branch: 

-- git push -u <remote> <your-branch-name>:<the-branch-name-on-repo>

-- git push -u origin featureB:featureBee

-- To Compare Newly-fetched branch to local copy of the same branch: 

--- git log <local-branch>..<tracking-branch>

--- git log featureA..origin/featureA

--- if everything is good, then run merge, merge it after comparing

Forked Public Project: 

- no permission to push, directly update master, main project

- you've got to get work to maintainers some other way. 

- 1st clone repo

- 2nd create topic branch for the patch or patch series 

-- git clone <https url>
-- cd project
-- git checkout -b featureA
... work ...
-- git commit 
... work ...
-- git commit

Note: rebase can be used to squash your work down to a single commit, or rearrange the work in the commits to make the patch easier for the maintainer to review. Rewritting History: https://git-scm.com/book/en/v2/ch00/_rewriting_history

-- go to original project page, click "Fork" and give it a name.

-- add the "myfork" url as a new remote to your local repo: 

-- git remote add myfork <https url>

-- push your new work to myfork repository

--- push your topic-branch to the forked (myfork) repository so that you don't have to "rewind" your master branch if your work is not accepted or is cherry-picked. 

--- if the maintainers merge, rebase or cherry-pick your work, you'll eventually get it back via pulling from their repository anyhow.

-- run: git push -u myfork featureA

-- Once you push your work to the forked repository, myfork, Notify the Maintainers of the Original project 

--- do a "pull request" via the website-Github "Pull Request" mechanism or you can run the "git request-pull" command and email the output to the maintainer manually. 

-- git request-pull command: 

--- git request-pull origin/master myfork

-- If you're not a maintainer: always have local-master track origin/master and do your work on topic-branches

--- doing work on topic branches allows you to discard, delete them if they are rejected. 

-- Have Work Themes Isolate In Topic Branches

--- makes it easier to rebase your work if tip of the origin repository has moved and your commits no longer apply cleanly.

--- if you have another topic or idea you want to work on, branch off from the main repo master branch, origin/master:

---- git checkout -b featureB origin/master 

---- or git switch -c featureB origin/master

--squash option: 

-- takes all work on the merged branch and squashes it into one changeset producing the repository stat as if a real merge happened.  

-- your future commit will have one parent only 

-- allows introduction of changes from another branch 

-- make more changes before recording new commit.

Public Project Over email:

- How to set up IMAP for this and etc. 






